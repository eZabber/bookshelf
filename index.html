<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cloud Library Final</title>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #2c3e50; --accent: #27ae60; --bg: #f8f7f4; --card: #ffffff; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg); max-width: 600px; margin: 0 auto; padding: 20px; color: #333; }
        
        header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px; }
        h1 { margin: 0; font-size: 1.5rem; font-weight: 700; color: var(--primary); }
        
        #auth-container { text-align: right; display: flex; flex-direction: column; align-items: flex-end; }
        #auth-btn { background: #4285F4; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-weight: 500; font-size: 0.85rem; cursor: pointer; transition: background 0.2s; }
        #auth-btn:disabled { background: #ccc; cursor: not-allowed; }
        
        #sheet-link { font-size: 0.75rem; color: #4285F4; margin-top: 8px; text-decoration: none; border-bottom: 1px dotted #4285F4; display: none; }
        #reset-btn { font-size: 0.7rem; color: #999; text-decoration: underline; background: none; border: none; margin-top: 5px; cursor: pointer; }

        #debug-log { background: #fee; color: #c00; padding: 10px; font-family: monospace; font-size: 12px; border: 1px solid #fcc; border-radius: 4px; margin-bottom: 15px; display: none; word-wrap: break-word; }

        .tabs { display: flex; background: #e0e0e0; border-radius: 8px; padding: 4px; margin-bottom: 20px; }
        .tab { flex: 1; text-align: center; padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.9rem; color: #666; }
        .tab.active { background: white; color: var(--primary); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        .controls { display: flex; gap: 8px; margin-bottom: 20px; }
        input { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; } 
        button.action-btn { padding: 10px 16px; border: none; border-radius: 8px; background: var(--primary); color: white; font-weight: 600; cursor: pointer; }
        button.scan-btn { background: var(--accent); }

        #reader-container { display: none; margin-bottom: 15px; }
        #reader { width: 100%; border-radius: 8px; overflow: hidden; background: black; }
        
        ul { list-style: none; padding: 0; }
        .book-card { background: var(--card); padding: 12px; margin-bottom: 12px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); display: flex; gap: 12px; align-items: start; }
        
        /* Thumb Logic: Fixed size, grey fallback */
        .book-thumb { width: 60px; height: 90px; background: #eee; border-radius: 4px; object-fit: cover; flex-shrink: 0; }
        
        .book-info { flex: 1; min-width: 0; }
        .book-title { font-weight: 600; font-size: 1rem; margin-bottom: 4px; line-height: 1.3; }
        .book-meta { color: #666; font-size: 0.85rem; margin-bottom: 8px; line-height: 1.4; }
        
        .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 5px; }
        .delete-btn { background: none; border: 1px solid #ff4d4d; color: #ff4d4d; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; }
        .move-btn { background: var(--accent); border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; }
        
        select.rating { display: block; margin-bottom: 8px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85rem; background: white; }

        /* MODAL STYLES */
        #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center; }
        .modal-content { background: white; padding: 20px; border-radius: 12px; width: 90%; max-width: 320px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .modal-cover { width: 100px; height: 150px; object-fit: cover; background: #eee; border-radius: 6px; margin-bottom: 15px; display: none; margin-left: auto; margin-right: auto; }
        .modal-title { font-size: 1.1rem; font-weight: bold; margin-bottom: 5px; }
        .modal-author { color: #666; font-size: 0.9rem; margin-bottom: 20px; }
        .modal-btns { display: flex; flex-direction: column; gap: 10px; }
        .btn-choice { padding: 12px; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; font-weight: 500; }
        .btn-read { background: var(--primary); color: white; }
        .btn-wish { background: var(--accent); color: white; }
        .btn-cancel { background: #eee; color: #333; }
    </style>
</head>
<body>

    <header>
        <h1>üìö My Shelf</h1>
        <div id="auth-container">
            <button id="auth-btn" disabled onclick="handleAuthClick()">Sign In</button>
            <a id="sheet-link" target="_blank" href="#">‚ÜóÔ∏è Open Sheet</a>
            <button id="reset-btn" onclick="hardReset()">Reset App</button>
        </div>
    </header>

    <div id="debug-log"></div>

    <div class="tabs">
        <div class="tab active" onclick="switchShelf('read', this)">Read</div>
        <div class="tab" onclick="switchShelf('wishlist', this)">Wishlist</div>
    </div>

    <div class="controls">
        <input type="text" id="isbn-input" placeholder="ISBN or Title">
        <button class="action-btn" onclick="handleManualAdd()">Add</button>
        <button class="action-btn scan-btn" onclick="startCamera()">üì∑</button>
    </div>

    <div id="reader-container">
        <div id="reader"></div>
        <button onclick="stopCamera()" style="width:100%;padding:10px;margin-top:10px;background:#eee;border:none;border-radius:4px;">Stop Camera</button>
    </div>

    <ul id="book-list"></ul>

    <div id="modal-overlay">
        <div class="modal-content">
            <img id="modal-img" class="modal-cover" src="" onerror="this.style.display='none'">
            <div id="modal-title" class="modal-title"></div>
            <div id="modal-author" class="modal-author"></div>
            <div class="modal-btns">
                <button class="btn-choice btn-read" onclick="confirmAdd('read')">Add to Read</button>
                <button class="btn-choice btn-wish" onclick="confirmAdd('wishlist')">Add to Wishlist</button>
                <button class="btn-choice btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

<script>
    // --- CONFIGURATION ---
    const CLIENT_ID = '579369345257-sqq02cnitlhcf54o5ptad36fm19jcha7.apps.googleusercontent.com'; 
    const SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const DISCOVERY = ['https://sheets.googleapis.com/$discovery/rest?version=v4'];

    let tokenClient, gapiInited = false, gisInited = false;
    let spreadsheetId = localStorage.getItem('sheetId');
    let currentShelf = 'read';
    let library = JSON.parse(localStorage.getItem('myLibrary')) || { read: [], wishlist: [] };
    let html5QrCode;
    let isSyncing = false;
    let syncPending = false;
    let pendingBook = null;
    let scanLocked = false; 

    // Init UI
    renderBooks();
    updateSheetLink();

    // Close Modal on Overlay Click
    document.getElementById('modal-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'modal-overlay') closeModal();
    });

    // --- HELPERS ---
    function logError(msg, err) {
        const div = document.getElementById('debug-log');
        div.style.display = 'block';
        div.innerText = "ERROR: " + msg + "\nDETAILS: " + JSON.stringify(err, null, 2);
        console.error(msg, err);
    }

    // Security: Escape HTML characters for Text
    function esc(s) {
        return (s ?? "").toString()
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    function getAuthorName(book) {
        return (book?.authors?.[0]?.name || "").toString();
    }
    
    function normKey(book) {
        return ((book?.title || "") + "|" + getAuthorName(book)).toLowerCase().trim();
    }

    function updateSheetLink() {
        const el = document.getElementById('sheet-link');
        if(spreadsheetId) {
            el.href = `https://docs.google.com/spreadsheets/d/${spreadsheetId}`;
            el.style.display = 'inline';
        } else {
            el.style.display = 'none';
        }
    }

    function hardReset() {
        if(!confirm("Disconnect from Google Sheet?")) return;
        localStorage.removeItem('sheetId');
        if(confirm("Also delete all local book data?")) {
            localStorage.removeItem('myLibrary');
        }
        location.reload();
    }

    // --- AUTH ---
    function gapiLoaded() {
        gapi.load('client', async () => {
            try {
                await gapi.client.init({ discoveryDocs: DISCOVERY });
                gapiInited = true; maybeEnableAuth();
            } catch(e) { logError("GAPI Init Failed", e); }
        });
    }
    function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID, scope: SCOPES,
            callback: async (resp) => {
                if (resp.error) return logError("Auth Failed", resp);
                gapi.client.setToken(resp);
                document.getElementById('auth-btn').innerText = "Working...";
                await doSync();
            },
        });
        gisInited = true; maybeEnableAuth();
    }
    function maybeEnableAuth() { if (gapiInited && gisInited) document.getElementById('auth-btn').disabled = false; }
    function handleAuthClick() { tokenClient.requestAccessToken({ prompt: 'consent' }); }

    // --- SYNC ---
    async function doSync() {
        try {
            if (!spreadsheetId) {
                document.getElementById('auth-btn').innerText = "Creating Sheet...";
                const createResp = await gapi.client.sheets.spreadsheets.create({
                    properties: { title: "My Book App Data" }
                });
                spreadsheetId = createResp.result.spreadsheetId;
                localStorage.setItem('sheetId', spreadsheetId);
                
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId, range: "Sheet1!A1:G1", valueInputOption: "RAW",
                    resource: { values: [["ID", "Title", "Author", "Shelf", "Rating", "Cover", "Date"]] }
                });
            }

            updateSheetLink();
            document.getElementById('auth-btn').innerText = "Downloading...";
            
            const resp = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId, range: 'Sheet1!A2:G999' });
            const rows = resp.result.values;

            if (rows && rows.length > 0) {
                const newLib = { read: [], wishlist: [] };
                rows.forEach(row => {
                    if(!row[0]) return;
                    const rawShelf = (row[3] || 'read').toLowerCase();
                    const safeShelf = (rawShelf === 'read' || rawShelf === 'wishlist') ? rawShelf : 'read';
                    
                    // SAFE DATA LOADING
                    const loadedCover = (row[5] === 'null' || !row[5]) ? null : row[5];
                    
                    newLib[safeShelf].push({
                        id: Number(row[0]),
                        title: row[1] || "Unknown Title",
                        authors: [{name: row[2] || "Unknown Author"}],
                        rating: Number(row[4] || 0),
                        cover: loadedCover,
                        dateRead: row[6] || ""
                    });
                });
                library = newLib;
                saveLocal(false);
            } else {
                await queueUpload();
            }
            document.getElementById('auth-btn').innerText = "Synced ‚úÖ";

        } catch(e) { 
            logError("Sync Failed", e);
            const code = e?.result?.error?.code;
            if (e?.status === 404 || code === 404) {
                spreadsheetId = null;
                localStorage.removeItem('sheetId');
                updateSheetLink();
                document.getElementById('auth-btn').innerText = "Sign In";
                document.getElementById('auth-btn').disabled = false;
                alert("Sheet deleted. Please Sign In again.");
            }
        }
    }

    async function queueUpload() {
        if (isSyncing) { syncPending = true; return; }
        isSyncing = true;
        document.getElementById('auth-btn').innerText = "Saving...";
        
        try { 
            // RETRY LOGIC (1 Retry)
            try {
                await uploadData();
            } catch (err) {
                if (err.status === 429 || err.status >= 500) {
                     await new Promise(r => setTimeout(r, 2000));
                     await uploadData(); 
                } else { throw err; }
            }
            document.getElementById('auth-btn').innerText = "Synced ‚úÖ";
        
        } catch(e) {
            logError("Upload Error", e);
            const code = e?.result?.error?.code;
            if (e?.status === 401 || e?.status === 403 || code === 401 || code === 403) {
                document.getElementById('auth-btn').innerText = "Sign In";
                document.getElementById('auth-btn').disabled = false;
                gapi.client.setToken(null);
                alert("Session expired. Please sign in again.");
            } else {
                document.getElementById('auth-btn').innerText = "Error ‚ùå";
            }
        } finally {
            isSyncing = false;
            if (syncPending) { 
                syncPending = false; 
                setTimeout(queueUpload, 0); 
            }
        }
    }

    async function uploadData() {
        let rows = [];
        ['read', 'wishlist'].forEach(shelf => {
            library[shelf].forEach(b => {
                const authorName = b.authors?.[0]?.name || "Unknown Author";
                rows.push([b.id, b.title, authorName, shelf, b.rating || 0, b.cover || 'null', b.dateRead || ""]);
            });
        });
        
        await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId, range: "Sheet1!A2:G999" });
        
        if(rows.length > 0) {
            await gapi.client.sheets.spreadsheets.values.update({
                spreadsheetId, range: "Sheet1!A2", valueInputOption: "RAW", resource: { values: rows }
            });
        }
    }

    // --- APP CORE ---
    function switchShelf(shelf, el) {
        currentShelf = shelf;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
        renderBooks();
    }

    // --- MODAL LOGIC ---
    function showModal(book) {
        pendingBook = book;
        const img = document.getElementById('modal-img');
        
        if (book.cover) {
            img.src = book.cover;
            img.style.display = "block"; // Changed to block for centering
        } else {
            img.removeAttribute('src');
            img.style.display = "none";
        }

        document.getElementById('modal-title').innerText = book.title;
        document.getElementById('modal-author').innerText = getAuthorName(book);
        document.getElementById('modal-overlay').style.display = "flex";
    }

    function closeModal() {
        document.getElementById('modal-overlay').style.display = "none";
        pendingBook = null;
        scanLocked = false; 
    }

    function confirmAdd(targetShelf) {
        if (!pendingBook) return;
        
        const key = normKey(pendingBook);
        const exists = library[targetShelf].some(b => normKey(b) === key);
        
        if (exists && !confirm("Book already in shelf. Add duplicate?")) {
            closeModal();
            return;
        }

        if (targetShelf === 'read') {
            pendingBook.dateRead = new Date().toISOString().split('T')[0];
        } else {
            pendingBook.dateRead = "";
        }
        
        library[targetShelf].push(pendingBook);
        closeModal();
        
        const tabIndex = targetShelf === 'read' ? 0 : 1;
        switchShelf(targetShelf, document.querySelectorAll('.tab')[tabIndex]);
        saveLocal(true, true); 
    }

    // --- SEARCH / SCAN LOGIC ---
    async function handleManualAdd() {
        const val = document.getElementById('isbn-input').value.trim();
        if (!val) return;
        const isNum = /^[\d-]+$/.test(val) && val.replace(/-/g, "").length >= 9;
        
        document.getElementById('isbn-input').value = ""; 
        
        if (isNum) { await fetchAndPrompt(val); } 
        else { await searchAndPrompt(val); }
    }

    async function searchAndPrompt(query) {
        try {
            const url = `https://openlibrary.org/search.json?q=${encodeURIComponent(query)}&limit=1`;
            const res = await fetch(url);
            const data = await res.json();
            if (data.docs && data.docs.length > 0) {
                const b = data.docs[0];
                const coverUrl = b.cover_i ? `https://covers.openlibrary.org/b/id/${b.cover_i}-M.jpg` : null;
                const author = b.author_name ? b.author_name[0] : "Unknown Author";
                
                showModal({
                    title: b.title, authors: [{name: author}],
                    cover: coverUrl, id: Date.now(), rating: 0
                });
            } else {
                if(confirm("No match. Add text manually?")) {
                    showModal({ title: query, authors: [{name: "Manual"}], cover: null, id: Date.now(), rating: 0 });
                } else {
                    scanLocked = false; 
                }
            }
        } catch(e) { 
            scanLocked = false; 
            alert("Search error"); 
        }
    }

    async function fetchAndPrompt(input) {
        const clean = input.replace(/\D/g, ""); 
        if(clean.length !== 10 && clean.length !== 13) {
            scanLocked = false; 
            return alert("Invalid ISBN.");
        }

        try {
            const res = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${clean}&jscmd=data&format=json`);
            const data = await res.json();
            const key = `ISBN:${clean}`;
            if (!data[key]) {
                 if(confirm("ISBN not found. Search by text?")) { 
                     searchAndPrompt("ISBN " + clean); 
                 } else {
                     scanLocked = false;
                 }
                 return;
            }
            const b = data[key];
            showModal({
                title: b.title, authors: b.authors || [{name: "Unknown"}],
                cover: b.cover ? b.cover.medium : null, id: Date.now(), rating: 0
            });
        } catch(e) { 
            scanLocked = false;
            alert("Error fetching book."); 
        }
    }

    function moveToRead(id) {
        const bookIndex = library['wishlist'].findIndex(b => b.id === id);
        if (bookIndex === -1) return;
        const book = library['wishlist'][bookIndex];
        
        library['wishlist'].splice(bookIndex, 1);
        book.dateRead = new Date().toISOString().split('T')[0]; 
        book.rating = 0; 
        library['read'].push(book);
        
        switchShelf('read', document.querySelectorAll('.tab')[0]); 
        saveLocal(true, true); 
    }

    function deleteBook(id) {
        if(!confirm("Delete?")) return;
        library[currentShelf] = library[currentShelf].filter(b => b.id !== id);
        saveLocal(true);
    }
    
    function updateRating(id, rating) {
        const book = library['read'].find(b => b.id === id);
        if(book) { book.rating = Number(rating); saveLocal(true); }
    }
    
    function saveLocal(shouldSync, skipRender = false) {
        localStorage.setItem('myLibrary', JSON.stringify(library));
        if (!skipRender) renderBooks();
        if (shouldSync && gapi.client.getToken()) queueUpload(); 
    }

    function renderBooks() {
        const list = document.getElementById('book-list');
        list.innerHTML = '';
        library[currentShelf].slice().reverse().forEach(b => {
            const li = document.createElement('li'); li.className = 'book-card';
            const author = getAuthorName(b);
            const safeTitle = esc(b.title);
            const safeAuthor = esc(author);
            const safeCover = esc(b.cover);
            
            let controlsHtml = '';
            let metaHtml = `<div class="book-meta">${safeAuthor}</div>`;
            
            if(currentShelf === 'read') {
                const dateDisplay = b.dateRead ? ` ‚Ä¢ ${b.dateRead}` : '';
                metaHtml = `<div class="book-meta">${safeAuthor}${dateDisplay}</div>`;
                controlsHtml = `
                <select class="rating" onchange="updateRating(${b.id}, this.value)">
                    <option value="0">Rate...</option>
                    ${[1,2,3,4,5].map(n => `<option value="${n}" ${b.rating==n?'selected':''}>${'‚≠ê'.repeat(n)}</option>`).join('')}
                </select>
                <div class="actions">
                    <button class="delete-btn" onclick="deleteBook(${b.id})">Remove</button>
                </div>`;
            } else {
                controlsHtml = `
                <div class="actions">
                    <button class="move-btn" onclick="moveToRead(${b.id})">‚úÖ Mark Read</button>
                    <button class="delete-btn" onclick="deleteBook(${b.id})">Remove</button>
                </div>`;
            }

            // ROBUST IMAGE FALLBACK: Swap to div on error
            const placeholderHtml = '<div class="book-thumb" style="background:#ddd"></div>';
            const imgTag = b.cover 
                ? `<img src="${safeCover}" class="book-thumb" onerror="this.outerHTML='${placeholderHtml.replace(/"/g, "&quot;")}'">` 
                : placeholderHtml;

            li.innerHTML = `
                ${imgTag}
                <div class="book-info">
                    <div class="book-title">${safeTitle}</div>
                    ${metaHtml}
                    ${controlsHtml}
                </div>
            `;
            list.appendChild(li);
        });
    }

    // --- CAMERA ---
    async function startCamera() {
        document.getElementById('reader-container').style.display = 'block';
        if (html5QrCode) { try { await html5QrCode.stop(); } catch(e){} }
        html5QrCode = new Html5Qrcode("reader");
        try {
            await html5QrCode.start(
                { facingMode: "environment" }, 
                { fps: 10, qrbox: { width: 250, height: 250 } }, 
                async (decodedText) => { 
                    if (scanLocked) return;
                    scanLocked = true;
                    await stopCamera(); 
                    await fetchAndPrompt(decodedText); 
                }
            );
        } catch(err) {
            document.getElementById('reader-container').style.display = 'none';
            alert("Camera failed: " + err);
        }
    }
    async function stopCamera() {
        document.getElementById('reader-container').style.display = 'none';
        if (html5QrCode) {
            try { await html5QrCode.stop(); } catch(e) {}
            try { html5QrCode.clear(); } catch(e) {}
            html5QrCode = null;
        }
    }
</script>
</body>
</html>
